knitr::opts_chunk$set(echo = TRUE)
d8 <- read.csv("../Data/experiment1_data_just8.csv")
head(d8)
df <- read.csv("./Data/experiment1_FINAL.csv")
df <- read.csv("../Data/experiment1_FINAL.csv")
summary(df)
table(df$iteration)
df <- subset(df,iteration<9)
table(df$iteration)
iteration <- c()        # generation (cultural condition) or round (individual condition) - this is the "age" of the category system
participant <- c()      # unique participant ID
lineage <- c()          # unique ID of the chain
skew <- c()             # S = one of the skewed frequency distributions, U = the uniform one
condition <- c()        # C = cultural, I = individual
trial <- c()            # test trial number (ranges 1 through 10)
RT <-c()                # time spent on the current test trial stim in milliseconds
stim_color <- c()       # greyscale code of the image in the current test trial
greys <- c(25,50,75,100,125,150,175,200,225,250)
stim_frequency <- c()   # frequency of the stim in the current test trial during training (normalized 0 to 1)
L_counts <- c(10,5,4,3,2,2,1,1,1,1)  # frequency per stim in the left skew condition
L_counts <- L_counts/sum(L_counts)
R_counts <- rev(L_counts)            # frequency per stim in the right skew condition
bounded <- c()          # 0 = no. Both neighbors to the stim have same category label as the stim.
system_to_bounded <- function(system_string) { # system = a string, ex: "1100000001"
result <- c() # result is an indexable array of binary digits
s <- as.numeric(strsplit(system_string, split="")[[1]])
m <- length(s)
# if the two labels are the same, assign 0. If the two lables are different, assign 1.
if ( s[1] == s[2] ) { result[1] <- 0 } else { result[1] <- 1 } # first one
if ( s[m] == s[m-1] ) { result[m] <- 0 } else { result[m] <- 1 } # last one
# if the three labels are the same, assign 0.  Otherwise, assign 1.
for (j in 2:(m-1)) { # the ones in the middle
if ( s[j] == s[j-1] && s[j] == s[j+1] ) { result[j] <- 0 } else { result[j] <- 1 }
}
return(result)
}
for (r in 1:length(df$X)) { # for each row in the original data frame (= the result of one round)
dis <- df[r,]$distribution
# get the elements to break up per test trial in the loop below
rts <- df[r,]$test_RTs
sti <- df[r,]$testset
# then break them up into an indexable array
rts <- as.numeric(strsplit(toString(rts),",")[[1]])
sti <- as.numeric(strsplit(toString(sti),",")[[1]])
bounded_codes <- system_to_bounded(toString(df[r,]$system512))
for (s in 1:10) { # for each stimulus in the testing set
# use as.character() to keep these as factors - otherwise they convert to numerics
lineage <- c(lineage,as.character(df[r,]$trajectory))
participant <- c(participant, as.character(df[r,]$participant))
condition <- c(condition, as.character(df[r,]$condition))
iteration <- c(iteration, df[r,]$iteration)
trial <- c(trial,s)
if (dis == "U") { skew <- c(skew, "U") } else { skew <- c(skew, "S") }
RT <- c(RT, rts[s])
stim_color <- c(stim_color, greys[sti[s]+1]) # +1 coz testset starts at zero
# work out what the stim frequency was
if (dis == "L") { fre <- L_counts[sti[s]+1] }
if (dis == "R") { fre <- R_counts[sti[s]+1] }
if (dis == "U") { fre <- 3/30 }
stim_frequency <- c(stim_frequency, fre)
# pull out the bounded code
bounded <- c(bounded, bounded_codes[sti[s]+1])
}
}
names(d)
stim_color <- (stim_color-25)/225
d <- data.frame(lineage,iteration,participant,trial,stim_color,stim_frequency,RT,bounded,skew,condition)
names(d)
summary(d)
length(unique(df$participant)) # 288 unique participants
length(unique(d$participant)) # 288 unique participants
unique(d$lineage) # 135 unique lineages
length(unique(d$lineage)) # 135 unique lineages
require(lme4)
full <- glmer(bounded ~ stim_frequency * stim_color * skew * condition * iteration  + (1|participant) + (1|lineage), data=d, family = "binomial")
full
ds <- subset(d,skew=="S")
table(d$skew)
table(ds$skew)
m3 <- glmer(bounded ~ stim_frequency * stim_color + (1|participant) + (1|lineage), data=ds, family="binomial")
summary(m3)
summary(m3)
################
# define what the columns in d are gonna be
iteration <- c()        # generation (cultural condition) or round (individual condition) - this is the "age" of the category system
participant <- c()      # unique participant ID
lineage <- c()          # unique ID of the chain
skew <- c()             # S = one of the skewed frequency distributions, U = the uniform one
condition <- c()        # C = cultural, I = individual
trial <- c()            # test trial number (ranges 1 through 10)
RT <-c()                # time spent on the current test trial stim in milliseconds
stim_color <- c()       # greyscale code of the image in the current test trial
# df$testset values map to this array of greyscale colors:
greys <- c(25,50,75,100,125,150,175,200,225,250)
# ex: testset 0 = greyscale 25, testset 4 = greyscale 125
# 25 is almost black, 250 is almost white
stim_color_rescale <- c()  # this one rescales stim color to a 0-1 range
stim_frequency <- c()   # frequency of the stim in the current test trial during training (normalized 0 to 1)
L_counts <- c(10,5,4,3,2,2,1,1,1,1)  # frequency per stim in the left skew condition
L_counts <- L_counts/sum(L_counts)
R_counts <- rev(L_counts)            # frequency per stim in the right skew condition
# is the current stimulus on the edge of a category boundary? According to the category system people produced on that testing round.
# uses the function defined below system_to_bounded()
bounded <- c()          # 0 = no. Both neighbors to the stim have same category label as the stim.
# 1 = yes. At least one of the neighbors to the stim had a difference category label.
################
# define extra functions
# input: a category system in string format (see df$system512)
# ex: "1100000001" where 0 = category A label, like "lem", 1 = category B label, like "vit"
# the order of the 10 labels map on to the greyscale color of each stim, defined in variable "greys" above.
# output: a different binary string format where
# 0 = stim has no boundary adjacent to it, 1 = stim has boundary adjacent
# example output for the input above: "0110000011"
system_to_bounded <- function(system_string) { # system = a string, ex: "1100000001"
result <- c() # result is an indexable array of binary digits
s <- as.numeric(strsplit(system_string, split="")[[1]])
m <- length(s)
# if the two labels are the same, assign 0. If the two lables are different, assign 1.
if ( s[1] == s[2] ) { result[1] <- 0 } else { result[1] <- 1 } # first one
if ( s[m] == s[m-1] ) { result[m] <- 0 } else { result[m] <- 1 } # last one
# if the three labels are the same, assign 0.  Otherwise, assign 1.
for (j in 2:(m-1)) { # the ones in the middle
if ( s[j] == s[j-1] && s[j] == s[j+1] ) { result[j] <- 0 } else { result[j] <- 1 }
}
return(result)
}
# example usage:
# system_to_bounded("1100000001")
################
# fill columns
for (r in 1:length(df$X)) { # for each row in the original data frame (= the result of one round)
dis <- df[r,]$distribution
# get the elements to break up per test trial in the loop below
rts <- df[r,]$test_RTs
sti <- df[r,]$testset
# then break them up into an indexable array
rts <- as.numeric(strsplit(toString(rts),",")[[1]])
sti <- as.numeric(strsplit(toString(sti),",")[[1]])
bounded_codes <- system_to_bounded(toString(df[r,]$system512))
for (s in 1:10) { # for each stimulus in the testing set
# use as.character() to keep these as factors - otherwise they convert to numerics
lineage <- c(lineage,as.character(df[r,]$trajectory))
participant <- c(participant, as.character(df[r,]$participant))
condition <- c(condition, as.character(df[r,]$condition))
iteration <- c(iteration, df[r,]$iteration)
trial <- c(trial,s)
if (dis == "U") { skew <- c(skew, "U") } else { skew <- c(skew, "S") }
RT <- c(RT, rts[s])
stim_color <- c(stim_color, greys[sti[s]+1]) # +1 coz testset starts at zero
# work out what the stim frequency was
if (dis == "L") { fre <- L_counts[sti[s]+1] }
if (dis == "R") { fre <- R_counts[sti[s]+1] }
if (dis == "U") { fre <- 3/30 }
stim_frequency <- c(stim_frequency, fre)
# pull out the bounded code
bounded <- c(bounded, bounded_codes[sti[s]+1])
}
}
# re-scale color from range 25-250 to 0-1
stim_color_rescale <- (stim_color-25)/225
# summary(stim_color_rescale)
d <- data.frame(lineage,iteration,participant,trial,stim_color,stim_frequency,RT,bounded,skew,condition)
summary(d)
# create a new dataframe (called d) from df - each row is a stimulus
################
# define what the columns in d are gonna be
iteration <- c()        # generation (cultural condition) or round (individual condition) - this is the "age" of the category system
participant <- c()      # unique participant ID
lineage <- c()          # unique ID of the chain
skew <- c()             # S = one of the skewed frequency distributions, U = the uniform one
condition <- c()        # C = cultural, I = individual
trial <- c()            # test trial number (ranges 1 through 10)
RT <-c()                # time spent on the current test trial stim in milliseconds
stim_color <- c()       # greyscale code of the image in the current test trial
# df$testset values map to this array of greyscale colors:
greys <- c(25,50,75,100,125,150,175,200,225,250)
# ex: testset 0 = greyscale 25, testset 4 = greyscale 125
# 25 is almost black, 250 is almost white
stim_color_rescale <- c()  # this one rescales stim color to a 0-1 range
stim_frequency <- c()   # frequency of the stim in the current test trial during training (normalized 0 to 1)
L_counts <- c(10,5,4,3,2,2,1,1,1,1)  # frequency per stim in the left skew condition
L_counts <- L_counts/sum(L_counts)
R_counts <- rev(L_counts)            # frequency per stim in the right skew condition
# is the current stimulus on the edge of a category boundary? According to the category system people produced on that testing round.
# uses the function defined below system_to_bounded()
bounded <- c()          # 0 = no. Both neighbors to the stim have same category label as the stim.
# 1 = yes. At least one of the neighbors to the stim had a difference category label.
################
# define extra functions
# input: a category system in string format (see df$system512)
# ex: "1100000001" where 0 = category A label, like "lem", 1 = category B label, like "vit"
# the order of the 10 labels map on to the greyscale color of each stim, defined in variable "greys" above.
# output: a different binary string format where
# 0 = stim has no boundary adjacent to it, 1 = stim has boundary adjacent
# example output for the input above: "0110000011"
system_to_bounded <- function(system_string) { # system = a string, ex: "1100000001"
result <- c() # result is an indexable array of binary digits
s <- as.numeric(strsplit(system_string, split="")[[1]])
m <- length(s)
# if the two labels are the same, assign 0. If the two lables are different, assign 1.
if ( s[1] == s[2] ) { result[1] <- 0 } else { result[1] <- 1 } # first one
if ( s[m] == s[m-1] ) { result[m] <- 0 } else { result[m] <- 1 } # last one
# if the three labels are the same, assign 0.  Otherwise, assign 1.
for (j in 2:(m-1)) { # the ones in the middle
if ( s[j] == s[j-1] && s[j] == s[j+1] ) { result[j] <- 0 } else { result[j] <- 1 }
}
return(result)
}
# example usage:
# system_to_bounded("1100000001")
################
# fill columns
for (r in 1:length(df$X)) { # for each row in the original data frame (= the result of one round)
dis <- df[r,]$distribution
# get the elements to break up per test trial in the loop below
rts <- df[r,]$test_RTs
sti <- df[r,]$testset
# then break them up into an indexable array
rts <- as.numeric(strsplit(toString(rts),",")[[1]])
sti <- as.numeric(strsplit(toString(sti),",")[[1]])
bounded_codes <- system_to_bounded(toString(df[r,]$system512))
for (s in 1:10) { # for each stimulus in the testing set
# use as.character() to keep these as factors - otherwise they convert to numerics
lineage <- c(lineage,as.character(df[r,]$trajectory))
participant <- c(participant, as.character(df[r,]$participant))
condition <- c(condition, as.character(df[r,]$condition))
iteration <- c(iteration, df[r,]$iteration)
trial <- c(trial,s)
if (dis == "U") { skew <- c(skew, "U") } else { skew <- c(skew, "S") }
RT <- c(RT, rts[s])
stim_color <- c(stim_color, greys[sti[s]+1]) # +1 coz testset starts at zero
# work out what the stim frequency was
if (dis == "L") { fre <- L_counts[sti[s]+1] }
if (dis == "R") { fre <- R_counts[sti[s]+1] }
if (dis == "U") { fre <- 3/30 }
stim_frequency <- c(stim_frequency, fre)
# pull out the bounded code
bounded <- c(bounded, bounded_codes[sti[s]+1])
}
}
# re-scale color from range 25-250 to 0-1
stim_color_rescale <- (stim_color-25)/225
# summary(stim_color_rescale)
d <- data.frame(lineage,iteration,participant,trial,stim_color,stim_color_rescale,stim_frequency,RT,bounded,skew,condition)
# make sure everything you want to be a factor is a factor
#d$participant <- as.factor(d$participant)
ds <- subset(d,skew=="S")
summary(d)
summary(ds)
m3 <- glmer(bounded ~ stim_frequency * stim_color_rescale + (1|participant) + (1|lineage), data=ds, family="binomial")
summary(m3)
summary(m3)
table(ds$bounded)
table(ds$stim_frequency)
table(ds$bounded,ds$stim_frequency)
table(ds$bounded,ds$stim_color)
